More Efficient Sybil Detection Mechanisms Leveraging
Resistance of Users to Attack Requestsâˆ—
Ali Safarpoor Dehkordi
Australian National University
Canberra, Australia
ali.safarpoordehkordi@anu.edu.au
Ahad N. Zehmakan
Australian National University
Canberra, Australia
ahadn.zehmakan@anu.edu.au
ABSTRACT
We investigate the problem of sybil (fake account) detection in
social networks from a graph algorithms perspective, where graph
structural information is used to classify users as sybil and benign.
We introduce the novel notion of user resistance to attack requests
(friendship requests from sybil accounts). Building on this notion,
we propose a synthetic graph data generation framework that sup-
ports various attack strategies. We then study the optimization
problem where we are allowed to reveal the resistance of a sub-
set of users with the aim to maximize the number of users which
are discovered to be benign and the number of potential attack
edges (connections from a sybil to a benign user). Furthermore, we
devise efficient algorithms for this problem and investigate their
theoretical guarantees. Finally, through a large set of experiments,
we demonstrate that our proposed algorithms improve detection
performance notably when applied as a preprocessing step for dif-
ferent sybil detection algorithms. The code and data used in this
work are publicly available on GitHub.1
CCS CONCEPTS
â€¢ Theory of computation â†’Graph algorithms analysis; â€¢
Human-centered computing â†’Social networks.
KEYWORDS
Sybil Detection, Social Networks, Algorithmic Graph Data Mining
ACM Reference Format:
Ali Safarpoor Dehkordi and Ahad N. Zehmakan. 2025. More Efficient Sybil
Detection Mechanisms Leveraging Resistance of Users to Attack Requests.
In Proc. of the 24th International Conference on Autonomous Agents and
Multiagent Systems (AAMAS 2025), Detroit, Michigan, USA, May 19 â€“ 23,
2025, IFAAMAS, 16 pages.
INTRODUCTION
Motivation. Online social networks (OSNs) like Facebook, Insta-
gram, and Twitter (now X) have become essential parts of our lives.
They are places where we connect with friends and family, get the
latest news, plan events, and even conduct business. Thus, they
have revolutionized many fundamental aspects of our lives.
âˆ—This is the full version of the paper accepted in The 24th International Conference on
Autonomous Agents and Multiagent Systems (AAMAS 2025) with appendices.
1GitHub repository: https://github.com/aSafarpoor/AAMAS2025-Paper/tree/main
This work is licensed under a Creative Commons Attribution Inter-
national 4.0 License.
Proc. of the 24th International Conference on Autonomous Agents and Multiagent Systems
(AAMAS 2025), Y. Vorobeychik, S. Das, A. NowÃ© (eds.), May 19 â€“ 23, 2025, Detroit, Michigan,
USA. Â© 2025 International Foundation for Autonomous Agents and Multiagent Systems
(www.ifaamas.org).
However, the rapid growth of OSNs has raised privacy and secu-
rity concerns as malicious entities exploit them for identity theft
and spreading harmful content. A key element is sybils (also re-
ferred to as â€œfakeâ€, â€œmaliciousâ€, and â€œfraudulentâ€ accounts), used
for spamming, malware, and phishing, causing financial and repu-
tational damage [1, 31]. Thus, detecting sybils is crucial for a safer
online environment.
Early Detection Mechanisms. Detecting sybils can be con-
ducted in different stages of the formation. The first stage is during
registration, by using data like IP, Captcha, and location [25, 44],
The next stage to detect sybils that pass through the registration is
based on their first actions after joining the network, such as the
ratio of accepted friend requests, the randomness of the requests
sent, or the total number of requests, cf. [8, 9].
Late Detection Mechanisms. While many sybils can be caught
using early detection mechanisms, more sophisticated attackers
can bypass these by mimicking benign users. Numerous studies
have focused on identifying these hard-to-find accounts. Some
research analyzes the content provided by users to detect fake or
malicious activities, cf. [32]. Other studies [12, 23] examine user
profiles, considering factors such as profile pictures, the number
of followers and followings, or the volume of activities like the
number of posts. While these methods are more in-depth than the
early detection mechanisms, they may still fail to identify sybils
that sophisticatedly mimic benign usersâ€™ behavior.
Graph Based Detection Mechanisms. While sybils have a
lot of power over manipulating information such as their IP, user-
name, number of posts, and profile pictures, which are used by the
aforementioned methods, they have very little control over their
position with respect to the overall network structure. Thus, a nat-
ural question arises: can network structural information be used to
detect sophisticated sybil attacks? More precisely, suppose we are
given a graph ğº, corresponding to a social network, where some
nodes (users) are labeled sybil or benign. The goal is to label the
remaining nodes as accurately as possible. Prior work has leveraged
various methods such as random walk [20], belief propagation [38],
and graph neural networks (GNN) [40].
Shortcomings of Exiting Methods. The existing algorithms [27,
37, 43] are usually designed under the homophily assumption and
very limited number of attack edges, that is, most edges (links)
in the graph are between nodes of the same type (sybil-to-sybil
or benign-to-benign) with significantly fewer edges in between
(sybil-to-benign or benign-to-sybil). Due to the lack of real-world
data, these algorithms are usually tested on synthetic graph models,
which are tailored to possess such homophily properties. How-
ever, based on current research [39], we know that the homophily
property is not satisfied in many real-world examples.
arXiv:2501.16624v1  [cs.SI]  28 Jan 2025
Missing Piece of Puzzle. One key aspect that steers the forma-
tion of connection in a network is how benigns react to friendship
requests from sybils. We introduce the notion of user resistance,
where a resistant user rejects such requests while a non-resistant
accepts them. (For simplicity, we suppose a user is either resistant
or non-resistant, but our results can be extended to the setup where
nodes have various degrees of resistance.) The notion of resistance
permits us to design a more dynamic graph generation framework
where, unlike prior static models [15, 42], the outcome graph is a
function of the attack strategy and resistance of users rather than
a simplified pre-assumption such as homophily. We then devise
effective and efficient mechanisms to leverage resistance informa-
tion for finding potential attack edges and benigns, which serve as
helpful preprocessing steps for sybil detection algorithms.
Attack Models. It is commonly assumed, cf. [27], that an at-
tacker connects its created sybil accounts together in a fashion
that it mimics benigns, for example, by copying the connections
between a set of benigns with the same size.
The vital question is how the connections between sybils and
the rest of the network are formed. Prior models [38] implant these
connections following a presumed structural property such as ho-
mophily. However, in reality, these connections are a function of
two variables: (i) the attackerâ€™s strategy to send connection requests
and (ii) whether a request that has been sent is accepted by the
corresponding benign, which is determined by their resistance.
Following this natural observation, we introduce a novel generic
modeling framework and three potential attack strategies. This
creates a powerful test bed for sybil detection mechanisms.
Potential Attack Edges. As mentioned, most sybil detection
algorithms function well when the homophily property holds. Still,
as observed in [15], this is often not the case, especially when
the attacker has a powerful strategy and users are non-resistant.
Thus, it would be beneficial to determine potential attack edges
(sybil-to-benign connections). Then, they can be removed or re-
ceive less weights to enhance the homophily and consequently the
performance of sybil detection algorithms.
Incoming edges for non-resistant benigns are potential attack
edges. The issue is that, in reality, we donâ€™t know which nodes
are resistant/non-resistant. However, we might have an estimate
of whether a node is resistant (e.g., based on their number of con-
nections, interaction behaviors, and so on). Furthermore, we can
determine whether a user is resistant by sending a sequence of
requests from a dummy sybil account. However, we donâ€™t want to
bombard the whole network with such dummy sybil requests. Thus,
we suppose we have a fixed budget ğ‘˜of the number of users whose
resistance can be revealed. We formulate this as an optimization
problem and provide an optimal linear time algorithm.
Discovering Benigns. If we know that a node ğ‘£is benign and
resistant, we can conclude that a node ğ‘¢with an edge to ğ‘£is also
benign. Now, if ğ‘¢is known to be resistant, we can conclude that
a node ğ‘¤, which has an edge to ğ‘¢, is benign too, and so on. How
many new benigns can be discovered if we are allowed to reveal the
resistance of ğ‘˜nodes? We prove that this problem is computation-
ally â€œhardâ€. However, we propose a greedy-based and traversing
algorithm, which turns out to be very performant based on exper-
iments on real-world graph data. In addition to potential attack
edge discovery from above, expanding the benign set can serve as
an important preprocessing step for sybil detection algorithms.
Enhancing Detection Algorithms by Preprocessing. Based
on the contributions mentioned above, we investigate the state-of-
the-art detection methods, including SybilSCAR [38], SybilWalk [20],
and SybilMetric [2], with and without preprocessing steps con-
ducted by our resistance-based mechanisms. We first examine the
performance of these methods on several real-world social networks
incorporated into our synthetic framework under three different
attack strategies. We then gauge the performance when our poten-
tial attack edge and benigns discovery mechanisms are applied as a
preprocessing step. They prove to be very impactful in enhancing
the accuracy performance.
Outline. In the rest of this section, we provide some basic defi-
nitions and an overview of some prior work. Our data generation
framework, accompanied by attack models, is provided in Section 2.
The maximizing benigns and potential attack edges discovery mech-
anisms using resistance information are given in Section 3.1 and 3.2.
Finally, the experimental results of our proposed mechanisms are
discussed in Section 4.
1.1
Preliminaries
Graph Definition. A social network is represented by a directed
graph ğº= (ğ‘‰, ğ¸) with node set ğ‘‰and edge set ğ¸âŠ†ğ‘‰Ã—ğ‘‰. We have
|ğ‘‰| = ğ‘›and |ğ¸| = ğ‘š. Nodes correspond to users; edges represent
connections, such as following (directed) or friendship (bidirec-
tional).
We define Î“in(ğ‘£) := {ğ‘¢: (ğ‘¢, ğ‘£) âˆˆğ¸} and Î“out(ğ‘£) := {ğ‘¢: (ğ‘£,ğ‘¢) âˆˆ
ğ¸} to be respectively the set of incoming and outgoing neighbors
of a node ğ‘£. Then, we define ğ‘‘in(ğ‘£) := |Î“in(ğ‘£)|, ğ‘‘out(ğ‘£) := |Î“out(ğ‘£)|
and ğ‘‘(ğ‘£) := ğ‘‘in(ğ‘£) +ğ‘‘out(ğ‘£). Let Î”in = max {ğ‘‘in(ğ‘£) | ğ‘£âˆˆğ‘‰} denote
the maximum incoming degree and Î”out = max {ğ‘‘out(ğ‘£) | ğ‘£âˆˆğ‘‰}.
We show an edge from ğ‘¢to ğ‘£by ğ‘’ğ‘¢ğ‘£, and if the edge is undirected,
we show that by Â¯ğ‘’ğ‘¢ğ‘£. In addition, for two subsets ğ‘‰1,ğ‘‰2 âŠ†ğ‘‰we
define ğœ•(ğ‘‰1,ğ‘‰2) := {ğ‘’ğ‘£ğ‘¢âˆˆğ¸: ğ‘£âˆˆğ‘‰1 âˆ§ğ‘¢âˆˆğ‘‰2}. A path in a graph
ğº= (ğ‘‰, ğ¸) is a sequence of nodes ğ‘£1, ğ‘£2, . . . , ğ‘£ğ‘˜where each adjacent
pair is connected by an edge, i.e., (ğ‘£ğ‘–, ğ‘£ğ‘–+1) âˆˆğ¸for 1 â‰¤ğ‘–â‰¤ğ‘˜âˆ’1.
Benign and Sybil Classification Problem. In this paper, we
aim to provide preprocessing algorithms which help mechanisms
solve the following problem.
Benign and Sybil Classification (BSC) Problem
Input: Given a graph ğº= (ğ‘‰, ğ¸) where nodes are labeled as Benign,
Sybil, or Unknown, partitioned into subsets ğµ, ğ‘†, and ğ‘ˆrespectively
(ğµâˆªğ‘†âˆªğ‘ˆ= ğ‘‰and (ğµâˆ©ğ‘†) âˆª(ğµâˆ©ğ‘ˆ) âˆª(ğ‘†âˆ©ğ‘ˆ) = âˆ…).
Goal: Maximize the number of correctly labeled nodes in ğ‘ˆ.
User Resistance. In the real world, each user can choose to
accept or reject sybil requests. Some users are more cautious and
reject such requests, while others might accept them. For simplicity,
we assume each user, which is represented as a node in a graph,
either accepts all sybil requests or rejects all of them. To model
this, we define a binary value ğ‘Ÿ: ğ‘£â†’{0, 1} to represent a userâ€™s
resistance to sybil requests, where 1 means resistant (rejecting)
and 0 means non-resistant (accepting). Since, in reality, the value
of ğ‘Ÿ(ğ‘£) is not known to us, we suppose we know a probability
function ğ‘ğ‘Ÿ(ğ‘£) whose value is more likely to be closer to 1 if ğ‘£
is resistant and 0 otherwise. Such estimates can be achieved in
practice by studying certain user features, such as the number of
incoming/outgoing connections, the number of known sybil/benign
neighbors, and content posted. In our paper, we suppose such a
probability distribution is given to us as input.
1.2
Related Work
Some mechanisms aim to detect sybils at the early stages. This could
be as early as registration time using techniques like captchas or
analyzing data such as registration time and IP addresses, cf. [25, 44].
The sybils that pass through these filters might be caught based on
their first activities, such as friendship requests, cf. [9].
While such early detection mechanisms are useful in identifying
a considerable fraction of sybils, more sophisticated attacks can
deceive them by mimicking benign users. Thus, there has been
a growing interest in leveraging network structure information
to detect more sophisticated attacks, cf. [20, 41]. This is because,
unlike information such as username or IP, sybil users have very
limited power to control their network structural properties. Below,
we give an overview of various existing methods.
Graph Metrics. One natural approach is finding graph metrics
that separate sybils and benigns. Asghari et al. [2] analyzed the
relationship between being sybil or benign based on metrics such as
degree, betweenness, eigenvector centrality, clustering coefficient,
and average shortest path length. Yoon [41] defined the graph
accessibility metric for nodes to identify sybils. Jethava and Rao [19]
proposed a hybrid approach, combining user behavior analysis with
graph-based techniques. They used metrics such as the Jaccard
index and betweenness centrality.
Random Walk. Random walk-based detection mechanisms
have particularly become popular, cf. [7, 45]. They usually rely on
the premise that a random walk starting from a sybil user is more
likely to encounter sybil users. SybilGuard [43] was one of the
first methods to leverage random walks for sybil detection. Sybil-
Limit [42] improved on this by enhancing scalability and providing
a tighter bound on the number of accepted sybils. SybilInfer [11] ad-
ditionally used Bayesian inference and Monte Carlo simulations to
provide a more robust mechanism. SybilRank [10] proposed using
a ranking algorithm that prioritizes nodes based on the degree-
normalized probability of a short random walk from a non-sybil
landing on them. SybilWalk [20] improved random walk-based
models by incorporating known benigns and sybils simultaneously.
This model defines two extra nodes as label nodes and then connects
known nodes to their respective label node.
Belief Propagation. Another popular approach, cf. [30], is to
assign some initial probability of being sybil to each node (where
known sybils get higher and known benigns get lower probabilities)
and then use some updating mechanism, called belief propagation,
to improve these probabilities. The idea is that a nodeâ€™s probability
(belief) is updated as a function of the probabilities of its neighbors.
SybilBelief [15] is a semi-supervised learning algorithm that uses
belief propagation to detect sybils. SybilSCAR [38] unified random
walk and belief propagation methods, applying local rules itera-
tively to identify sybils. GANG [37] improved previous models by
using directed graphs. SybilFuse [14] employed collective classifica-
tion by training local classifiers to calculate trust scores first, then
propagating these scores using weighted random walk and belief
propagation to improve detection accuracy.
Machine Learning. Machine Learning (ML) methods for sybil
detection usually involve feature extraction, model training, and
classification. Some basic ML methods include SVM, Logistic Regres-
sion, and Random Forest, cf.[22, 23, 34]. Furthermore, deep learning
methods can process raw data and capture complex structures,
making them ideal for sybil detection. Goyal et al. [16] used graph
convolutional network (GCN) to learn structural features, while
Borkar et al. [6] employed recurrent networks for text content pro-
cessing, followed by clustering for sybil detection. Recent advances
leverage graph neural networks (GNNs) and attention mechanisms.
Yang and Zheng [40] used attention-based GNNs, Khan et al.[21]
developed a GNN-based framework to analyze user profiles and
connections, and Liu et al.[26] integrated diverse attributes using
heterogeneous GNNs.
ATTACK MODELS
To effectively evaluate detection algorithms, it is essential to pro-
vide high-quality datasets. Many existing datasets suffer from a lack
of proper labeling, as they are often labeled manually and are quite
limited in size. To tackle this issue, some synthesized datasets have
been provided [15, 27] but they still fall short in various aspects.
For example, [15] uses a synthesized model to generate the sybil
area, which is less favorable than using real-world data. Further-
more, the existing models [27] make special assumptions on the
strategy employed by the attacker and the structure of the edges
between sybil and benign parts, for example, uniform random edges.
They then leverage these structural properties to devise algorithms
that are tailored for this setting. However, the proposed algorithms
should ideally be agnostic of the attack strategy deployed by the
attacker since the attacker can adopt various attack strategies. More-
over, the availability of diverse datasets generated by various attack
strategies enhances the reliability of evaluation outcomes. This
encourages us to synthesize datasets with different characteristics.
We will see that the notion of user resistance, defined in this paper,
forms an excellent foundation for synthesizing realistic datasets.
To synthesize a labeled network, one needs to define the nodes
and their labels and the edge set, especially attack edges, formed
from sybils to benigns. An existing dataset of online social net-
works is usually used as the benign set, treating all individuals
as benign [38]. For the sybil set, a common approach is that the
attacker may replicate a subgraph from the real graph to secure an
initial real-world structure. If attackers avoid using this strategy,
their presence becomes readily detectable through the analysis of
simple graph features.
Following the above description, the sybil set ğ‘†will be created
based on the chosen subset ğµâ€² âŠ‚ğµ, where ğµis the benign set. Then,
the edges between nodes in ğ‘†are formed to copy the corresponding
structure in ğµâ€². Each node ğ‘£âˆˆğµâ€² has a corresponding copy in ğ‘†
and vice versa; these nodes are referred to as dual of each other.
Following a specific strategy, the attacker sends requests to the
benigns. If a benign has resistance 1, the request is rejected; oth-
erwise, it is accepted. Recall that we show the resistance of each
node ğ‘£with ğ‘Ÿ(ğ‘£), which is set to 0 (non-resistant) or 1 (resistant).
For example, if the resistance of all nodes is set to 1, all the sent
requests are rejected, and no edge is formed from ğ‘†to ğµ. However,
in reality, not all nodes are resistant.
Letâ€™s note that while our algorithms start from known benign
nodes and do not consider sybil resistance, sybils can indeed have
resistance in real-world scenarios. Attackers might program sybils
to reject specific requests to mimic realistic behavior or avoid de-
tection methods that use test requests. Additionally, sybils might
reject requests from nodes suspected to be other sybils, especially
without collaboration among attackers, to avoid higher homophily
and a higher risk of being detected.
As stated, our proposed framework is not limited to a particular
attack strategy and facilitates the study of various strategies. Below,
we provide three natural approaches which may be used by the
attacker. Before that, we explain some concepts which are shared
among them.
Assume the number of Attack Edges from node ğ‘ ğ‘–âˆˆğ‘†to ğµis
ğ´ğ¸(ğ‘–). As discussed above, we suppose that the attacker â€œcopiesâ€
the subgraph among a subset of benigns ğµâ€² âŠ‚ğµas ğ‘†. To mimic a
benign behavior further, one natural strategy is to ensure that each
node in ğ‘†has as many edges to ğµ\ ğµâ€² as its dual. More precisely,
one aims to have ğ´ğ¸(ğ‘–) = |ğœ•({ğ‘‘ğ‘¢ğ‘ğ‘™(ğ‘ ğ‘–)}, ğµ\ ğµâ€²)|.
Furthermore, it is plausible to consider adding edges from the
benign region (ğµ) to the sybil region (ğ‘†). Given the low likelihood
that real users spontaneously connect to sybils, we posit that only
nodes that have already accepted an edge from a sybil user might
reciprocally connect back to it. Formally, consider each edge (ğ‘¢, ğ‘£) âˆˆ
ğ¸where ğ‘¢âˆˆğ‘†and ğ‘£âˆˆğµ. We add the reverse edge (ğ‘£,ğ‘¢) with a
certain probability, say 1/2, for each such edge.
Below, we describe our proposed attack strategies. Please refer
to Appendix A for a detailed pseudocode.
Random Attack Strategy. In this strategy, the attacker sim-
ply sends random requests to benigns. The number of requests
from each node ğ‘–âˆˆğ‘†is ğ‘Â· ğ´ğ¸(ğ‘–). For an appropriate choice of
constant ğ‘, as a function of the average resistance in ğµ, the ex-
pected number of attack edges from ğ‘–will be our desired value
ğ´ğ¸(ğ‘–) = |ğœ•({ğ‘‘ğ‘¢ğ‘ğ‘™(ğ‘ ğ‘–)}, ğµ\ ğµâ€²)| (the same applied to the strategies
below).
Preferential Attachment Attack Strategy. The attacker might
prefer to target nodes with the least resistance, especially those
that have accepted more attack requests in the past. This also aligns
with the power-law behavior observed in real-world social networks.
Thus, we leverage the preferential attachment model of network
growth. We use a modified version of the preferential attachment
model based on the BarabÃ¡si-Albert (BA) graph [3], named Modified
BA. This takes into account both the original degree of each node
and the number of accepted attack requests. This modification has
been applied to take into account that the attacker is more likely
to send requests to nodes that have already proven vulnerable (by
accepting previous sybil requests).
BFS Attack Strategy. To enhance the difficulty of detecting
sybil behavior, another natural approach is that each sybil attempts
connections with the neighbors of its dual in the benign region. The
acceptance of these connection requests, however, depends on the
targeted nodeâ€™s resistance. To achieve the desired number of attack
edges for each sybil node ğ‘ ğ‘–(that is, the aforementioned value of
ğ´ğ¸(ğ‘–)), we process nodes using a BFS algorithm. For each node ğ‘ ğ‘–,
the BFS starts from ğ‘‘ğ‘¢ğ‘ğ‘™(ğ‘ ğ‘–). If the number of nodes that BFS can
reach is not enough, a preferential attachment attack strategy is
utilized to complete the process.
PREPROCESSING ALGORITHMS
In this part of the paper, we will study the problems of Maximizing
Benigns (in Section 3.1) and Discovering Potential Attack Edges (in
Section 3.2) leveraging the resistance probability information. We
propose algorithms for solving these problems. As will be discussed
in Section 4, the outcome of these algorithms serves as a very
valuable preprocessing step for detection algorithms.
3.1
Maximizing Benigns
Maximizing Benigns (MB) Problem
Input: Given ğº= (ğ‘‰, ğ¸), sets of benigns and sybils ğµand ğ‘†such
that ğµâˆ©ğ‘†= âˆ…, budget ğ‘˜, and resistant probability distribution
ğ‘ğ‘Ÿ: ğ‘‰â†’[0, 1].
Goal: Maximize the number of newly discovered benigns by re-
vealing the resistance of ğ‘˜nodes.
An algorithm is permitted to reveal the resistance of nodes in
a node set ğ´of size ğ‘˜as a reveal set. Each selected node ğ‘¢will be
revealed to be resistant (ğ‘Ÿ(ğ‘¢) = 1) or not, with probability ğ‘ğ‘Ÿ(ğ‘¢),
independently. (In real life, we send a set of friend requests from
some dummy sybils to a nodeğ‘¢and determine whether it is resistant,
but our budget has a bound to avoid bombarding all users with
such requests.) Then, the goal is to maximize the number of newly
discovered benigns.
Observation 3.1. A nodeğ‘¢inğ‘‰\ (ğµâˆªğ‘†) can be newly discovered
benign if and only if it has a path to a node in ğµand each node ğ‘£on
that path (except, potentially, ğ‘¢itself) has revealed to have ğ‘Ÿ(ğ‘£) = 1.
Definition 3.1. ğ‘“(ğ´) is the expected number of discovered be-
nigns upon revealing the nodes in the reveal set ğ´.
3.1.1
Hardness Results. We prove that our problem is computa-
tionally hard by a reduction from the Maximum Coverage Problem.
Definition 3.2 (Maximum Coverage (MC) Problem). Given
set ğ‘Š= {ğ‘¤1,ğ‘¤2, Â· Â· Â· ,ğ‘¤â„}, collection of subsets ğ‘„= {ğ‘1,ğ‘2, Â· Â· Â· ,ğ‘ğ‘™},
âˆ€ğ‘ğ‘–âˆˆğ‘„: ğ‘ğ‘–âŠ†ğ‘Š, and budget ğ‘˜, what is the maximum number of
elements which can be covered by a set ğ´âŠ‚ğ‘„of size ğ‘˜? We say a set
ğ‘ğ‘–covers an element ğ‘¤ğ‘—if ğ‘¤ğ‘—âˆˆğ‘ğ‘–.
Theorem 3.1 ([13]). There is no (1âˆ’1
ğ‘’)-approximation polynomial
time algorithm for the MC problem unless NP âŠ†DTIME(ğ‘›ğ‘‚(log logğ‘›)).
Assume ğ¼= âŸ¨ğ‘Š,ğ‘„,ğ‘˜âŸ©is an instance of MC. We define a transfor-
mation to convert ğ¼into ğ¼â€² = âŸ¨ğº, ğµ,ğ‘†,ğ‘˜, ğ‘ğ‘Ÿ(Â·)âŸ©, which is an instance
of MB. Without loss of generality, we assume that each ğ‘¤ğ‘–âˆˆğ‘Š
appears in at least one of the subsets ğ‘ğ‘—âˆˆğ‘„(otherwise, they could
be simply ignored because they cannot be covered at all). Now, we
present the transformer in the following.
Transformer. To define the transformer to convert ğ¼to ğ¼â€², we
first need to construct the MC problem in graph space asğº= (ğ‘‰, ğ¸).
We define ğ‘‰= ğ‘‰ğ‘„âˆªğ‘‰ğ‘Š, where ğ‘‰ğ‘„= {ğ‘£ğ‘ğ‘–: 1 â‰¤ğ‘–â‰¤ğ‘™} and
ğ‘‰ğ‘Š= {ğ‘£ğ‘¤ğ‘–: 1 â‰¤ğ‘–â‰¤â„}. Note that ğ‘‰ğ‘„âˆ©ğ‘‰ğ‘Š= âˆ…. We also define
ğ¸= {(ğ‘£ğ‘¤ğ‘–, ğ‘£ğ‘ğ‘—) : ğ‘¤ğ‘–âˆˆğ‘ğ‘—}. In addition, ğ‘˜is the same, ğ‘†= âˆ…, ğµ= ğ‘‰ğ‘„,
and ğ‘ğ‘Ÿ(ğ‘£) = 1 for all nodes (which means we know all nodes are
resistant). An example is provided in Appendix B.
Connection Between Optimal Solutions. For any arbitrary
instance of the MC problem, let ğ‘‚ğ‘ƒğ‘‡MC denote the optimal solution,
and similarly ğ‘‚ğ‘ƒğ‘‡MB for the MB problem. We claim that
ğ‘‚ğ‘ƒğ‘‡MC = ğ‘‚ğ‘ƒğ‘‡MB
(1)
First, let ğ´be an optimal solution for the MB problem. Note that
ğ´âˆ©ğ‘‰ğ‘Š= âˆ…because revealing a node in ğ‘‰ğ‘Šdoes not result in
discovering any new benign. Consider that set ğ´ğ‘, which includes a
setğ‘ğ‘–if and only if ğ‘£ğ‘ğ‘–âˆˆğ´. If a node ğ‘£ğ‘¤ğ‘—is newly discovered benign
by revealing ğ´, then there is a node ğ‘£ğ‘ğ‘–such that (ğ‘£ğ‘¤ğ‘—, ğ‘£ğ‘ğ‘–) âˆˆğ¸and
ğ‘£ğ‘ğ‘–âˆˆğ´. This implies that ğ‘¤ğ‘—âˆˆğ‘ğ‘–and ğ‘ğ‘–âˆˆğ´ğ‘. Therefore, ğ‘¤ğ‘—is
covered by ğ´ğ‘. This implies that ğ‘‚ğ‘ƒğ‘‡MC â‰¥ğ‘‚ğ‘ƒğ‘‡MB.
It remains to prove that ğ‘‚ğ‘ƒğ‘‡MC â‰¤ğ‘‚ğ‘ƒğ‘‡MB. Let ğ´ğ‘âŠ‚ğ‘„generate
an optimal solution for the MC problem. Define ğ´to include a
node ğ‘£ğ‘ğ‘–if and only if ğ‘ğ‘–âˆˆğ´ğ‘. Consider an element ğ‘¤ğ‘—, which is
covered by ğ´ğ‘, and let ğ‘ğ‘–be a set which covers it. Then, ğ‘£ğ‘ğ‘–âˆˆğ´and
(ğ‘£ğ‘¤ğ‘—, ğ‘£ğ‘ğ‘–) âˆˆğ¸. Thus, ğ‘¤ğ‘—will be a newly discovered benign since
ğ‘¤ğ‘—âˆˆğ‘‰\ ğµ, and it has an edge to a node with resistance 1. This
implies that ğ‘‚ğ‘ƒğ‘‡MC â‰¤ğ‘‚ğ‘ƒğ‘‡MB.
Inapproximability. Assume there exists a polynomial-time
(1âˆ’1
ğ‘’)-approximation algorithmğ´ğ‘™ğ‘”MB, that solves the MB problem.
For an instance of the MC problem, we can use the previously
mentioned transformer to construct an instance of our problem in
polynomial time. Then, we apply ğ´ğ‘™ğ‘”MB to solve the constructed
instance, yielding a solution ğ‘†ğ‘œğ‘™MB. Using the same argument as
previously described for the relationship between optimal solutions,
we can show that ğ‘†ğ‘œğ‘™MC â‰¥ğ‘†ğ‘œğ‘™MB. Thus, ğ‘†ğ‘œğ‘™MC â‰¥ğ‘†ğ‘œğ‘™MB â‰¥(1 âˆ’
ğ‘’)ğ‘‚ğ‘ƒğ‘‡MB. With the help of Equation (1) we can conclude ğ‘†ğ‘œğ‘™MC â‰¥
(1 âˆ’1
ğ‘’)ğ‘‚ğ‘ƒğ‘‡MC
Therefore, we get an (1 âˆ’1
ğ‘’)-approximation algorithm for MC,
which operates in polynomial time. However, according to Theo-
rem 3.1, this is impossible unless NP âŠ†DTIME(ğ‘›ğ‘‚(log logğ‘›)). Thus,
we have the theorem below.
Theorem 3.2. There is no (1âˆ’1
ğ‘’)-approximation polynomial time
algorithm for the MB problem unless NP âŠ†DTIME(ğ‘›ğ‘‚(log logğ‘›)).
3.1.2
Greedy Approach. For the MB problem, we can use the clas-
sical greedy algorithm, which iteratively reveals the node that max-
imizes the expected number of newly discovered benigns (an exact
description is given in Appendix C). According to Nemhauser et
al. [29], if ğ‘“(Â·) is non-negative, monotone and sub-modular, then
this algorithm is (1 âˆ’1
ğ‘’)-approximation (which matches the bound
from Theorem 3.2).
However, we prove that the objective function ğ‘“(Â·), in fact, is not
submodular (please see Appendix D for a proof). Thus, we cannot
conclude (1âˆ’1
ğ‘’)-approximation guarantee. On the positive side, the
greedy algorithm has proven to be performant, cf. [4, 17], even if the
submodularity property doesnâ€™t hold. Thus, we study this further.
However, it turns out that computing ğ‘“(Â·) is #P-hard, implying that
the greedy algorithm is not polynomial time. To tackle this issue,
we show that we can estimate ğ‘“(Â·) with an arbitrarily small error
parameter using the Monte Carlo method.
#P-hardness. We rely on a reduction from ğ‘-ğ‘Connectedness for
Induced Subgraphs Problem, which is known to be #P-hard [33].
ğ‘-ğ‘Connectedness for Induced Subgraphs (CIS):
Input: Given a directed graph ğº= (ğ‘‰, ğ¸) and ğ‘,ğ‘âˆˆğ‘‰.
Goal: What is the number of induced subgraphs of ğºsuch that
there is a path from ğ‘to ğ‘.
Theorem 3.3. Computing ğ‘“(Â·) is #P-hard.
Proof. Suppose ğº= (ğ‘‰, ğ¸) and ğ‘,ğ‘âˆˆğ‘‰are given as the in-
put of CIS problem. We consider two instances of our problem to
compute ğ‘“(Â·). First consider graph ğº= (ğ‘‰, ğ¸), ğµ= {ğ‘}, ğ‘†= âˆ…,

ğ‘Ÿ(ğ‘£) = 1
ğ‘£âˆˆğ‘‰\ {ğ‘,ğ‘}
ğ‘Ÿ(ğ‘£) = 1
ğ‘£âˆˆ{ğ‘,ğ‘}
, and reveal set ğ´= ğ‘‰. The second case
is identical to the first case, except we add a node ğ‘â€² and add an edge
from ğ‘â€² to ğ‘. Letâ€™s call this graphğºâ€² = (ğ‘‰â€², ğ¸â€²), whereğ‘‰â€² = ğ‘‰âˆª{ğ‘â€²}.
Furthermore, again ğµ= {ğ‘}, ğ‘†= âˆ…, the values of ğ‘Ÿ(ğ‘£) are the same
for all nodes, and ğ‘Ÿ(ğ‘â€²) is any arbitrary value (its choice doesnâ€™t
impact our argument), and ğ´= {ğ‘‰}. See Figure 1 for a visualization.
Figure 1: The construction used in the proof of #P-hardness.
Let ğ‘“âˆ’ğ‘â€² (ğ´) and ğ‘“+ğ‘â€² (ğ´) denote the value of ğ‘“(ğ´), the expected
number of discovered benigns, in the first and second case, respec-
tively. Firstly, we observe that ğ‘â€² is discovered to be benign if and
only if ğ‘is discovered to be benign. This implies that ğ‘“+ğ‘â€² (ğ´) âˆ’
ğ‘“âˆ’ğ‘â€² (ğ´) is equal to the probability of the node ğ‘being discovered
to be benign. Secondly, note that each of the nodes in ğ‘‰\ {ğ‘,ğ‘} is
revealed to be resistant or not with probability 1/2, independently.
Thus, based on Observation 3.1, the probability that ğ‘is revealed
to be benign is the same as having a path from ğ‘to ğ‘once we
remove each node in ğ‘‰\ {ğ‘,ğ‘} with probability 1/2. Combining the
aforementioned two points, we can conclude that ğ‘“+ğ‘â€² (ğ´) âˆ’ğ‘“âˆ’ğ‘â€² (ğ´)
is equal to the fraction of all 2ğ‘›âˆ’2 possible induced subgraphs ob-
tained from removing nodes in ğ‘‰\ {ğ‘,ğ‘} in graph ğº, where there
is a path from ğ‘to ğ‘.
So far we concluded that the solution to CIS problem is equal
to (ğ‘“+ğ‘â€² (ğ´) âˆ’ğ‘“âˆ’ğ‘â€² (ğ´)) Ã— 2ğ‘›âˆ’2. Since the provided transformer is
polynomial time and CIS is #P-hard, we conclude that the problem
of computing ğ‘“(Â·) is #P-hard as well.
â–¡
Monte Carlo Greedy Algorithm. Algorithm 1 modifies the classi-
cal greedy approach by using the Monte Carlo method to estimate
ğ‘“(Â·) since, as we proved, its computation is #P-hard. The function
EST(Â·) runs the revealing process ğ‘…times and computes the number
of discovered benigns each time. Then, the average values found
are returned as an estimation of the original expectation.
As part of the function EST(Â·), to compute the number of dis-
covered benigns based on ğ‘Ÿ(Â·) and the reveal set ğ´, we apply a BFS
starting from known benigns in ğ´. During the BFS, only nodes with
resistance 1 (starting from ğ´) are added to the queue, marking their
neighbors as discovered. This ensures every discovered node has
a path of nodes with resistance 1 to an initial benign, meeting the
criterion in Observation 3.1. The pseudocode of this algorithm is
provided in Appendix E.
Algorithm 1 Monte Carlo Greedy Algorithm
Input ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†, budget ğ‘˜, ğ‘ğ‘Ÿ(Â·),ğœ–, ğ›¼
Output ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘ğ‘™_ğ‘ ğ‘’ğ‘¡ğ´
1: Initialize ğ´â†âˆ…
2: for ğ‘–= 1 to ğ‘˜do
3:
ğ‘£â†arg maxğ‘¤âˆˆğ‘‰\ğ´Est(ğ´âˆª{ğ‘¤}, ğ‘ğ‘Ÿ(Â·), ğµ,ğ‘†,ğœ–, ğ›¼)
4:
ğ´â†ğ´âˆª{ğ‘£}
5: return ğ´
6: function Est(ğ´, ğ‘ğ‘Ÿ(Â·), ğµ,ğ‘†,ğœ–, ğ›¼)
7:
Initialize ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡â†0
8:
ğ‘…â†

ğ‘˜2Î”2
in ln(
1âˆ’ğ›¼)
2ğœ–2

9:
for ğ‘…iterations do
10:
Assign resistance ğ‘Ÿ(ğ‘£) for each ğ‘£âˆˆğ´based on ğ‘ğ‘Ÿ(ğ‘£)
11:
ğ‘›ğ‘’ğ‘¤_ğ‘ğ‘’ğ‘›ğ‘–ğ‘”ğ‘›â†number of discovered benigns based
on ğµ, ğ‘†, and assigned resistances.
12:
ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡â†ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡+ ğ‘›ğ‘’ğ‘¤_ğ‘ğ‘’ğ‘›ğ‘–ğ‘”ğ‘›
13:
return ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡/ğ‘…
Furthermore, using Hoeffdingâ€™s inequality [18], one can achieve
arbitrary error margin ğœ–and gain confidence ğ›¼by setting the num-
ber of iterations ğ‘…â‰¥ğ‘˜2Î”2
in ln(
1âˆ’ğ›¼)
2ğœ–2
. The time complexity of the
algorithm is ğ‘‚(ğ‘˜Â· ğ‘…Â· (ğ‘›2 +ğ‘›ğ‘š)). One can check that, for constant ğœ–
and ğ›¼, the run time is polynomial. Please refer to Appendix F and G
for more details on these two points.
3.1.3
Proposed Traversing Algorithm. We propose an algorithm
that iteratively selects the node expected to reveal the maximum
number of newly discovered benigns. More precisely, we keep a set
of nodes ğ‘such that if a node in ğ‘is revealed to be resistant, then
we can conclude all its incoming neighbors are benign. Based on
Observation 3.1, these nodes already have a path to a node in ğµ, and
all nodes on the path are revealed to be benign. Thus, initially, ğ‘is
simply ğµ, but it is updated as the algorithm reveals more resistant
nodes. However, among all the incoming neighbors of a node ğ‘£,
we are only interested in the ones that will be â€œnewlyâ€ discovered
benign. Thus, we define Ë†Î“(ğ‘£), which excludes unrelated nodes such
as the already discovered ones (that is, ğµâˆªğ‘†) or already discovered
benigns. We continuously update Ë†Î“(ğ‘£) as more nodes are revealed
and added to ğ´. More precisely, for each node ğ‘£, if ğ‘Ÿ(ğ‘£) is revealed to
be 1, then we must consider every in-neighbor ğ‘¢of ğ‘£, and for each
out-neighbor ğ‘¤of ğ‘¢, we then remove ğ‘¢from the set of in-neighbors
of ğ‘¤. This is because ğ‘¢has already been discovered to be benign.
The pseudocode of this algorithm is provided in Algorithm 2.
The For loop runs in ğ‘‚(ğ‘›+ ğ‘š). The While loop is computed
ğ‘˜times, and the lines 7-9 can clearly be executed in ğ‘‚(ğ‘›). The
complexity of the If statement part isğ‘‚(Î”inÂ·Î”out). This is achieved
by using the appropriate data structure (please refer to Appendix H
for more details). Thus, the time complexity of this algorithm is
ğ‘‚((ğ‘›+ğ‘š) + ğ‘˜Â· (ğ‘›+ Î”in Â· Î”out)), which can be bounded by ğ‘‚(ğ‘˜ğ‘›2).
Algorithm 2 Traversing Algorithm
Input ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†, budget ğ‘˜, ğ‘ğ‘Ÿ(Â·)
Output ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘ğ‘™_ğ‘ ğ‘’ğ‘¡ğ´
1: ğ´â†âˆ…
2: ğ‘â†ğµ
3: for ğ‘£âˆˆğ‘‰do
4:
Ë†Î“in(ğ‘£) â†Î“in(ğ‘£) \ (ğµâˆªğ‘†)
5:
ğ›¾in(ğ‘£) = | Ë†Î“in(ğ‘£)|
6: while |ğ´| < ğ‘˜do
7:
pick ğ‘£with highest ğ‘ğ‘Ÿ(ğ‘£) Â· ğ›¾in(ğ‘£) between nodes in ğ‘
8:
ğ´â†ğ´âˆª{ğ‘£}
9:
ğ‘â†ğ‘\ {ğ‘£}
10:
if ğ‘Ÿ(ğ‘£) = 1 then
11:
ğ‘â†ğ‘âˆªË†Î“in(ğ‘£)
12:
for ğ‘¢âˆˆË†Î“in(ğ‘£) do
13:
for ğ‘¤âˆˆÎ“out(ğ‘¢) do
14:
Ë†Î“in(ğ‘¤) â†Ë†Î“in(ğ‘¤) \ {ğ‘¢}
15:
ğ›¾in(ğ‘¤) â†ğ›¾in(ğ‘¤) âˆ’1
16: return ğ´
3.2
Discovering Potential Attack Edges
Definition 3.3. An edge ğ‘’= (ğ‘¢, ğ‘£) is a Potential Attack Edge
(PAE) if ğ‘¢âˆˆğ‘‰\ (ğµâˆªğ‘†), ğ‘£âˆˆğµ, and ğ‘Ÿ(ğ‘£) = 0. In other words, it is an
incoming edge to a benign ğ‘£with ğ‘Ÿ(ğ‘£) = 0.
Discovering Potential Attack Edges Problem
Input: Given ğº= (ğ‘‰, ğ¸), sets of benigns and sybils ğµand ğ‘†such
that ğµ,ğ‘†âŠ†ğ‘‰, ğµâˆ©ğ‘†= âˆ…, budget ğ‘˜, and probability of resistant
ğ‘ğ‘Ÿ: ğ‘‰â†’[0, 1].
Goal: Maximize expected number of discovered potential attack
edges by revealing ğ‘Ÿ(ğ‘£) of ğ‘˜nodes from ğµ.
For each node ğ‘£, we know ğ‘‘in(ğ‘£) and ğ‘ğ‘Ÿ(ğ‘£), and (1 âˆ’ğ‘ğ‘Ÿ(ğ‘£)) Â·
|Î“in(ğ‘£) \ (ğµâˆ©ğ‘†)| is the expected number of edges which will be dis-
covered by revealing the node ğ‘£. Since there is no overlap between
edges discovered by each revealed node, choosing ğ‘˜nodes with
the highest value of (1 âˆ’ğ‘ğ‘Ÿ(ğ‘£)) Â· |Î“in(ğ‘£) \ (ğµâˆ©ğ‘†)| is the optimal
solution. This is outlined in Algorithm 3. For choosing the top ğ‘˜
nodes based on the computed values, we can use the median of
medians algorithm [5], which runs in O(ğ‘›). Thus, the overall time
complexity is linear.
Algorithm 3 Proposed Algorithm: Select Top ğ‘˜Nodes
Input Input ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†, budget ğ‘˜, ğ‘ğ‘Ÿ(Â·)
Output List of ğ‘˜nodes
1: ğ‘›ğ‘œğ‘‘ğ‘’_ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ğ‘ â†âˆ…
2: for each node ğ‘£in ğµdo
3:
value â†(1 âˆ’ğ‘ğ‘Ÿ(ğ‘£)) Â· |Î“in(ğ‘£) \ (ğµâˆ©ğ‘†)|
4:
ğ‘›ğ‘œğ‘‘ğ‘’_ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ğ‘ â†ğ‘›ğ‘œğ‘‘ğ‘’_ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ğ‘ âˆª{(ğ‘£, value)}
5: ğ‘¡ğ‘œğ‘_ğ‘˜_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†top ğ‘˜nodes of ğ‘›ğ‘œğ‘‘ğ‘’_ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ğ‘ based on ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’
using median of medians algorithm
6: return top_k_nodes
As we will discuss, we can reduce the weight of discovered PAEs
as a preprocessing step to assist sybil detection algorithms.
EXPERIMENTS
After establishing our experiments setting in Sections 4.1 and 4.2, we
test our proposed algorithms for maximizing benigns problem and
potential attack edges problem in Section 4.3. Then, in Section 4.4,
we study the impact of applying our algorithms as a preprocessing
step for various sybil/benign classification methods.
4.1
Experimental Setup
We use real-world graph data as the benign set. Then, our at-
tack strategies are used to generate sybils and their connections
to sybil/benigns. For the graph, the data used include Facebook,
LastFM, and Twitter from SNAP [24]. In addition, we use, Pokec
network 2 (we use only the subgraph induced by benigns). Some sta-
tistics of these networks are presented in Appendix I. For undirected
networks, we assume the edges in both directions exist.
After generating sybils and attack edges in each dataset, as ex-
plained in the next section, we randomly selected 2% of benigns
and an equal number of sybils for the training set. The remaining
sybils were included in the test set, along with an equal number of
benigns. This means the size of known benigns for Facebook, Pokec,
LastFM, and Twitter datasets are 80, 200, 150, and 200, respectively.
4.2
Attack Strategies
To choose the parameters in our attack models, we rely on some
real-world statistics. Facebook reports indicate that the proportion
of sybils is around 16% [28]. A 2013 study also found that 10% of
Twitter users were fake [36]. Thus, we choose the size of the sybil
set to be around 10% of the network in our attack strategies.
Furthermore, Vishwanath [35] conducted a study involving the
creation of fake Facebook profiles and sending friend requests to
students in a large university. It was observed that only 30% of
students declined friend requests from fake Facebook profiles, 52%
were undecided after two weeks, and 18% accepted immediately.
Based on these results, we chose 25% of nodes to be non-resistant.
To compute the probability of resistance ğ‘ğ‘Ÿ(ğ‘£) for a node ğ‘£based
on resistance ğ‘Ÿ(ğ‘£), we generate a random number ğ‘¥between 0
and 1 and then we use ğ‘ğ‘Ÿ(ğ‘£) = (1 âˆ’ğ‘Ÿ(ğ‘£))ğ‘¥3 + ğ‘Ÿ(ğ‘£)(1 âˆ’ğ‘¥3). We
choose this simple formula to introduce randomness while giving
higher probabilities when ğ‘Ÿ(ğ‘£) = 1 and lower probabilities when
ğ‘Ÿ(ğ‘£) = 0. For example, for ğ‘Ÿ(ğ‘£) = 1, the probability of ğ‘ğ‘Ÿ(ğ‘£) â‰¥0.5
is 0.79, and the average probability value is 0.75. In addition, in
all attack strategies, we set ğ‘= 4 (please refer to Section 2 for the
parameters of the attack models) since we aim for a non-resistance
ratio of 25%. This way, the number of accepted attacks for a sybil ğ‘ ğ‘–
in expectation will be 25
100 Â· ğ‘Â· ğ´ğ¸(ğ‘–) = ğ´ğ¸(ğ‘–), which is our desired
value. Some statistics on the outcome of the attack strategies are
provided in the Appendix J.
4.3
Preprocessing
In this section, we evaluate our proposed algorithms for maximizing
benigns and potential attack edges problems.
2https://github.com/binghuiwang/sybildetection/blob/master/Directed_Pokec.rar (ac-
cessed July 20, 2024)
4.3.1
Maximizing Benigns. We compare our proposed algorithms,
Monte Carlo Greedy (Algorithm 1) and Traversing (Algorithm 2),
against the following baseline methods.
1. Random. Randomly selectğ‘˜nodes from benign set ğµto reveal.
2. Highest-Resistance. Pick ğ‘˜nodes with highest ğ‘ğ‘Ÿ(Â·) from ğµ.
3. Highest-Resistance-and-Degree. Pick ğ‘˜nodes ğ‘£with high-
est ğ‘ğ‘Ÿ(ğ‘£).|Î“in(ğ‘£) \ (ğµâˆªğ‘†)| from ğµ.
Between our two proposed algorithms, Traversing reveals the
resistance of each selected node and uses that outcome information
when selecting the next nodes, while the Monte Carlo Greedy does
not. To make this a fairer comparison, we also consider a Monte
Carlo Greedy variant, which reveals each selected nodeâ€™s resistance.
This is called Resistance Aware Monte Carlo Greedy (please refer
to Appendix K for an exact description of this algorithm).
Figure 2 illustrates the performance of different algorithms on
the Facebook dataset. (The high variance in the results of the Monte
Carlo Greedy algorithms in this experiment is attributed to the fact
that the run was performed only once.) We observe that our pro-
posed algorithms, Traversing and two variants of Monte Carlo,
significantly outperform other algorithms. Among our proposed al-
gorithms, the Traversing algorithm performs better than the Monte
Carlo Greedy algorithms. Furthermore, based on our experiments,
the Traversing algorithm is substantially faster than the two Monte
Carlo Greedy algorithms. For example, for the Facebook dataset and
Preferential Attachment attack strategy, with a budget of ğ‘˜= 30,
the Traversing algorithm completes in 119 milliseconds, while the
Monte Carlo Greedy algorithm takes 52 minutes. Thus, the Travers-
ing algorithm is not only more accurate, but also significantly faster.
For other datasets, similar results are provided in the Appendix L.
4.3.2
Potential Attack Edges. We now evaluate the performance
of our Proposed Algorithm 3 for the potential attack edges (PAE)
problem against the Random algorithm, which makes ğ‘˜random
choices. Figure 3 (top row) illustrates the number of PAEs found by
each algorithm for a range of budgets. Our algorithm outperforms
the Random algorithm. This is unsurprising since our algorithm is
optimal, as we proved in Section 3.2.
One natural question is what fraction of PAEs are, in fact, attack
edges (edges from sybil to benign). We report this information in
Figure 3 (second row). As one can observe, for our algorithm, around
20% of found PAEs are attack edges for various budget choices. To
get a better understanding of how good this performance is, we
consider the Full-Knowledge algorithm. We suppose this algorithm
knows all the values of resistance (note that this information is
not available to our algorithm) and aims to greedily pick nodes
which maximize the ratio of attack edges over PAEs. While for
small budgets, the gap is large, as the budget grows, the ratio of
attack edges over PAEs for our algorithm almost matches the Full-
Knowledge algorithm, which is impressive considering that our
algorithm doesnâ€™t know the exact values of resistanceğ‘Ÿ(Â·). For other
datasets, similar results are provided in the Appendix M.
4.4
Classification Algorithms
Our algorithms for discovering benigns and potential attack edges
can act as a preprocessing step for various sybil detection algo-
rithms. We analyze the performance of three state-of-the-art detec-
tion algorithms, with and without such preprocessing step.
Figure 2: The number of discovered benigns by each algorithm when the budget ranges from 1 to ğ‘˜in the maximizing benigns
problem on the Facebook dataset and for different attack strategies.
We consider the SybilWalk [20] and SybilSCAR [38] algorithms.
We also analyze a node classifier algorithm based on logistic re-
gression that we call SybilMetric [2]. We first executed each of
these algorithms without any preprocessing. We then applied the
Traversing algorithm to maximize the number of benigns (our best
algorithm for maximizing benigns based on our experiments in
the previous section) before running the detection strategies. In
the final setup, we also used our potential attack edges discover-
ing algorithm on both the initial known benigns and the newly
identified benigns from the first preprocessing step. Since detection
algorithms usually rely on homophily property, removing (or reduc-
ing the weight of) attack edges could benefit them. Therefore, in
the last setup, before running the detection algorithms, the weights
for the discovered PAEs were adjusted to reduce their importance.
Furthermore, in all experiments, for both preprocessing phases,
the budget is set to 1% of benigns. We used the same setup as the
prior work for the studied detection algorithms.
Our comparison results for the Facebook dataset are shown in
Table 1. To measure the performance of the detection algorithms,
we use AUC (Area Under the Curve), which is commonly used by
the prior work since it is less affected by biases compared to accu-
racy. Based on these results, the performance of all three algorithms
is improved after adding maximizing benigns outputs. Using discov-
ered PAEs as a preprocessing step also enhances the AUC in some
cases, but not always. This flags that one may need to incorporate
the information regarding the PAEs directly into these algorithms
instead of just reducing weights as we did to get a stronger boost in
the performance. (This would be an interesting potential avenue for
future research.) Thus, overall, our preprocessing steps, especially
discovering benigns, can significantly boost the performance of
detection strategies. For other datasets, similar results are provided
in the Appendix N.
It is also worth emphasizing that our preprocessing steps are
not computationally demanding. More precisely, in most cases,
the computational overhead added by the preprocessing step is
negligible in comparison to the time required by the detection
algorithm itself.
Figure 3: The number of discovered PAEs for different bud-
gets (first row) and the percentage of attack edges relative to
the number of discovered PAEs (second row) on the Facebook
dataset. Each column represents a different attack strategy.
CONCLUSION
In this paper, we introduced novel attack strategies for synthesizing
more realistic and generic datasets by introducing the concept of
user resistance. We then considered two optimization problems
where we leveraged resistance information to discover benigns
and potential attack edges. We introduced several algorithms and
theoretically analyzed their runtime and solution accuracy. We
then showed the outcomes of these algorithms contain valuable
information that can be used as a preprocessing step for detection
algorithms. We conducted a large set of experiments that confirmed
the positive impact of our preprocessing algorithms.
Future research could explore dynamic attack strategies to en-
hance the adaptability of sybil detection algorithms. Developing
bias-robust algorithms is also essential, as current methods are
vulnerable to dataset biases, especially when preprocessing reveals
new benigns and skews the dataset. In addition, developing algo-
rithms for maximizing benigns problem with theoretical guarantees
could be a potential avenue for future work.
Table 1: Performance of SybilSCAR, SybilWalk, and SybilMet-
ric with and without preprocessing on the Facebook dataset.
Init represents the setup without preprocessing. MB incor-
porates discovered benigns by the Traversing algorithm.
MB+PAE incorporates both discovered benigns and PAEs.
Attack
Strategy
Step
SybilSCAR
AUC
SybilWalk
AUC
SybilMetric
AUC
Random
Init
0.924
0.966
1.00
MB
0.988
0.998
1.00
MB+PAE
0.988
0.998
0.99
BA
Init
0.876
0.929
1.00
MB
0.954
0.972
1.00
MB+PAE
0.944
0.972
1.00
BFS
Init
0.986
0.985
0.97
MB
0.995
0.996
0.99
MB+PAE
0.991
0.997
1.00
REFERENCES
[1] Kayode Sakariyah Adewole, Nor Badrul Anuar, Amirrudin Kamsin, Kasturi Dewi
Varathan, and Syed Abdul Razak. 2017. Malicious accounts: Dark of the social
networks. Journal of Network and Computer Applications 79 (2017), 41â€“67.
[2] Sara Asghari, Mostafa Haghir Chehreghani, and Morteza Haghir Chehreghani.
2022. On using node indices and their correlations for fake account detection. In
2022 IEEE International Conference on Big Data (Big Data). IEEE, 5656â€“5661.
[3] Albert-LÃ¡szlÃ³ BarabÃ¡si and RÃ©ka Albert. 1999. Emergence of scaling in random
networks. science 286, 5439 (1999), 509â€“512.
[4] Andrew An Bian, Joachim M. Buhmann, Andreas Krause, and Sebastian Tschi-
atschek. 2017. Guarantees for Greedy Maximization of Non-submodular Func-
tions with Applications. In Proceedings of the 34th International Conference on
Machine Learning (Proceedings of Machine Learning Research, Vol. 70), Doina
Precup and Yee Whye Teh (Eds.). PMLR, 498â€“507.
[5] Manuel Blum, Robert W Floyd, Vaughan R Pratt, Ronald L Rivest, and Robert E
Tarjan. 1973. Time bounds for selection. J. Comput. System Sci. 7, 4 (1973),
448â€“461. https://doi.org/10.1016/S0022-0000(73)80033-9
[6] Bharat S Borkar, Dipak R Patil, Ashok V Markad, and Manish Sharma. 2022.
Real or fake identity deception of social media accounts using recurrent neural
network. In 2022 International Conference on Fourth Industrial Revolution Based
Technology and Practices (ICFIRTP). IEEE, 80â€“84.
[7] Yazan Boshmaf, Dionysios Logothetis, Georgos Siganos, Jorge LerÃ­a, Jose Lorenzo,
Matei Ripeanu, Konstantin Beznosov, and Hassan Halawa. 2016. Ãntegro: Lever-
aging victim prediction for robust fake account detection in large scale OSNs.
Computers & Security 61 (2016), 142â€“168.
[8] Adam Breuer, Ran Eilat, and Udi Weinsberg. 2020. Friend or Faux: Graph-Based
Early Detection of Fake Accounts on Social Networks. In Proceedings of The Web
Conference 2020. Association for Computing Machinery, 1287â€“1297.
[9] Adam Breuer, Nazanin Khosravani, Michael Tingley, and Bradford Cottel. 2023.
Preemptive Detection of Fake Accounts on Social Networks via Multi-Class
Preferential Attachment Classifiers. In Proceedings of the 29th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining (Long Beach, CA, USA)
(KDD â€™23). Association for Computing Machinery, New York, NY, USA, 105â€“116.
[10] Qiang Cao, Michael Sirivianos, Xiaowei Yang, and Tiago Pregueiro. 2012. Aiding
the detection of fake accounts in large scale social online services. In 9th USENIX
symposium on networked systems design and implementation (NSDI 12). USENIX
Association, 197â€“210.
[11] George Danezis and Prateek Mittal. 2009. Sybilinfer: Detecting sybil nodes using
social networks.. In Ndss, Vol. 9. San Diego, CA, 1â€“15.
[12] Buket ErÅŸahin, Ã–zlem AktaÅŸ, Deniz KÄ±lÄ±nÃ§, and Ceyhun Akyol. 2017. Twitter
fake account detection. In 2017 international conference on computer science and
engineering (UBMK). IEEE, 388â€“392.
[13] Uriel Feige. 1998. A threshold of ln n for approximating set cover. Journal of
ACM 45, 4 (1998), 634â€“652.
[14] Peng Gao, Binghui Wang, Neil Zhenqiang Gong, Sanjeev R Kulkarni, Kurt
Thomas, and Prateek Mittal. 2018. Sybilfuse: Combining local attributes with
global structure to perform robust sybil detection. In 2018 IEEE conference on
communications and network security (CNS). IEEE, 1â€“9.
[15] Neil Zhenqiang Gong, Mario Frank, and Prateek Mittal. 2014. Sybilbelief: A
semi-supervised learning approach for structure-based sybil detection. IEEE
transactions on information forensics and security 9, 6 (2014), 976â€“987.
[16] Bharti Goyal, Nasib Singh Gill, Preeti Gulia, Om Prakash, Ishaani Priyadarshini,
Rohit Sharma, Ahmed J Obaid, and Kusum Yadav. 2023. Detection of fake accounts
on social media using multimodal data with deep learning. IEEE Transactions on
Computational Social Systems (2023).
[17] Jianxiong Guo, Yi Li, and Weili Wu. 2019. Targeted protection maximization
in social networks. IEEE Transactions on Network Science and Engineering 7, 3
(2019), 1645â€“1655.
[18] Wassily Hoeffding. 1994. Probability inequalities for sums of bounded random
variables. The collected works of Wassily Hoeffding (1994), 409â€“426.
[19] Gordhan Jethava and Udai Pratap Rao. 2022. User behavior-based and graph-
based hybrid approach for detection of sybil attack in online social networks.
Computers and Electrical Engineering 99 (2022), 107753.
[20] Jinyuan Jia, Binghui Wang, and Neil Zhenqiang Gong. 2017. Random walk based
fake account detection in online social networks. In 2017 47th annual IEEE/IFIP
international conference on dependable systems and networks (DSN). IEEE, 273â€“
284.
[21] Zafran Khan, Zeeshan Khan, Byung-Geun Lee, Hong Kook Kim, and Moongu
Jeon. 2024. Graph neural networks based framework to analyze social media
platforms for malicious user detection. Applied Soft Computing 155 (2024), 111416.
[22] Priyanka Kondeti, Lakshmi Pranathi Yerramreddy, Anita Pradhan, and Gandharba
Swain. 2021. Fake account detection using machine learning. In Evolutionary Com-
puting and Mobile Sustainable Networks: Proceedings of ICECMSN 2020. Springer,
791â€“802.
[23] Ngoc C Le, Manh-Tuan Dao, Hoang-Linh Nguyen, Tuyet-Nhi Nguyen, and Hue
Vu. 2020. An application of random walk on fake account detection problem:
A hybrid approach. In 2020 RIVF International Conference on Computing and
Communication Technologies (RIVF). IEEE, 1â€“6.
[24] Jure Leskovec and Andrej Krevl. 2014. SNAP Datasets: Stanford Large Network
Dataset Collection. Retrieved July 20, 2024 from http://snap.stanford.edu/data
[25] Xiao Liang, Zheng Yang, Binghui Wang, Shaofeng Hu, Zijie Yang, Dong Yuan,
Neil Zhenqiang Gong, Qi Li, and Fang He. 2021. Unveiling fake accounts at
the time of registration: An unsupervised approach. In Proceedings of the 27th
ACM SIGKDD conference on knowledge discovery & data mining. Association for
Computing Machinery, 3240â€“3250.
[26] Ziqi Liu, Chaochao Chen, Xinxing Yang, Jun Zhou, Xiaolong Li, and Le Song.
2018. Heterogeneous graph neural networks for malicious account detection. In
Proceedings of the 27th ACM international conference on information and knowledge
management. Association for Computing Machinery, 2077â€“2085.
[27] Haoyu Lu, Daofu Gong, Zhenyu Li, Feng Liu, and Fenlin Liu. 2023. Sybilhp:
Sybil detection in directed social networks with adaptive homophily prediction.
Applied Sciences 13, 9 (2023), 5341.
[28] Martin Moore. 2023. Fake accounts on social media, epistemic uncertainty and
the need for an independent auditing of accounts. Internet Policy Review 12, 1
(2023).
[29] George L. Nemhauser, Laurence A. Wolsey, and Marshall L. Fisher. 1978. An analy-
sis of approximations for maximizing submodular set functionsâ€”I. Mathematical
Programming 14 (1978), 265â€“294.
[30] Judea Pearl. 1988. Probabilistic Reasoning in Intelligent Systems: Networks of
Plausible Inference. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.
[31] Devakunchari Ramalingam and Valliyammai Chinnaiah. 2018. Fake profile
detection techniques in large-scale online social networks: A comprehensive
review. Computers & Electrical Engineering 65 (2018), 165â€“177.
[32] Santosh Kumar Uppada, K Manasa, B Vidhathri, R Harini, and B Sivaselvan.
2022. Novel approaches to fake news and fake account detection in OSNs: user
social engagement and visual content centric model. Social Network Analysis and
Mining 12, 1 (2022), 52.
[33] Leslie G Valiant. 1979. The complexity of enumeration and reliability problems.
siam Journal on Computing 8, 3 (1979), 410â€“421.
[34] EstÃ©e Van Der Walt and Jan Eloff. 2018. Using machine learning to detect fake
identities: bots vs humans. IEEE access 6 (2018), 6540â€“6549.
[35] Arun Vishwanath. 2018. Why Do So Many People Fall for Fake Profiles Online?
Retrieved April 18, 2024 from https://theconversation.com/why-do-so-many-
people-fall-for-fake-profiles-online-102754
[36] Keith Wagstaff. 2013. 1 in 10 Twitter Accounts Fake, Say Researchers.
Re-
trieved April 18, 2024 from https://www.nbcnews.com/technology/1-10-twitter-
accounts-fake-say-researchers-2d11655362
[37] Binghui Wang, Neil Zhenqiang Gong, and Hao Fu. 2017. GANG: Detecting
fraudulent users in online social networks via guilt-by-association on directed
graphs. In 2017 IEEE International Conference on Data Mining (ICDM). IEEE,
465â€“474.
[38] Binghui Wang, Le Zhang, and Neil Zhenqiang Gong. 2017. SybilSCAR: Sybil
detection in online social networks via local rule based propagation. In IEEE
INFOCOM 2017-IEEE Conference on Computer Communications. IEEE, 1â€“9.
[39] Fan Xu, Nan Wang, Hao Wu, Xuezhi Wen, Xibin Zhao, and Hai Wan. 2024.
Revisiting graph-based fraud detection in sight of heterophily and spectrum. In
Proceedings of the AAAI Conference on Artificial Intelligence, Vol. 38. 9214â€“9222.
[40] Peipei Yang and Zhuoyuan Zheng. 2020. Fake account detection with attention-
based graph convolution networks. In 2020 IEEE 3rd International Conference on
Automation, Electronics and Electrical Engineering (AUTEEE). IEEE, 106â€“110.
[41] Minji Yoon. 2021. Graph fraud detection based on accessibility score distributions.
In Machine Learning and Knowledge Discovery in Databases. Research Track:
European Conference, ECML PKDD 2021, Bilbao, Spain, September 13â€“17, 2021,
Proceedings, Part II 21. Springer, 483â€“498.
[42] Haifeng Yu, Phillip B Gibbons, Michael Kaminsky, and Feng Xiao. 2008. Sybil-
limit: A near-optimal social network defense against sybil attacks. In 2008 IEEE
Symposium on Security and Privacy. IEEE, 3â€“17.
[43] Haifeng Yu, Michael Kaminsky, Phillip B Gibbons, and Abraham Flaxman. 2006.
Sybilguard: defending against sybil attacks via social networks. In Proceedings of
the 2006 conference on Applications, technologies, architectures, and protocols for
computer communications. Association for Computing Machinery, 267â€“278.
[44] Dong Yuan, Yuanli Miao, Neil Zhenqiang Gong, Zheng Yang, Qi Li, Dawn Song,
Qian Wang, and Xiao Liang. 2019. Detecting fake accounts in online social
networks at the time of registrations. In Proceedings of the 2019 ACM SIGSAC
conference on computer and communications security. Association for Computing
Machinery, 1423â€“1438.
[45] Xiaoying Zhang, Hong Xie, Pei Yi, and John CS Lui. 2022. Enhancing Sybil detec-
tion via social-activity networks: A random walk approach. IEEE Transactions on
Dependable and Secure Computing 20, 2 (2022), 1213â€“1227.
A
PSEUDOCODE OF ATTACK STRATEGIES
The pseudocode for the Random, Preferential Attachment, and
BFS attack strategies are provided in Algorithms A.1, A.2, and A.3,
respectively.
Attack Strategy A.1 Random
Input ğº= (ğ‘‰, ğ¸),ğ‘†, ğµ,ğ´ğ¸(Â·),ğ‘Ÿ(Â·),ğ‘
Output Generated graph ğºâ€²
1: for each node ğ‘ ğ‘–in set ğ‘†do
2:
ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†âˆ…
3:
for ğ‘–â†1 to ğ‘Â· ğ´ğ¸(ğ‘–) do
4:
choose a node ğ‘¢from (ğµ\ ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ ) randomly
5:
ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ âˆª{ğ‘¢}
6:
if ğ‘Ÿ(ğ‘¢) = 0 then
7:
ğ¸â†ğ¸âˆª{(ğ‘ ğ‘–,ğ‘¢)}
8:
with probability 1
2: ğ¸â†ğ¸âˆª{(ğ‘¢,ğ‘ ğ‘–)}
9: return ğºâ€² = (ğ‘‰, ğ¸)
Attack Strategy A.2 Preferential Attachment (PreAt)
Input ğº= (ğ‘‰, ğ¸),ğ‘†, ğµ,ğ´ğ¸(Â·),ğ‘Ÿ(Â·),ğ‘
Output Generated graph ğºâ€²
1: function modified_BA(ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†)
2:
for each node ğ‘¢in ğµdo
3:
ğ‘ƒ1(ğ‘¢) â†BA probability of in-degree ğ‘¢from ğµ
4:
ğ‘ƒ2(ğ‘¢) â†BA probability of in-degree ğ‘¢from ğ‘†
5:
ğ‘ƒ(ğ‘¢) â†ğ‘ƒ1(ğ‘¢)+ğ‘ƒ2(ğ‘¢)
6:
return ğ‘ƒ
7: for each node ğ‘ ğ‘–in set ğ‘†do
8:
ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†âˆ…
9:
ğ‘ƒâ†modified_BA
10:
for ğ‘–â†1 to ğ‘Â· ğ´ğ¸(ğ‘–) do
11:
ğ‘¢â†a random node from (ğµ\ ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ )
following the probability vector ğ‘ƒ
12:
ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ âˆª{ğ‘¢}
13:
if ğ‘Ÿ(ğ‘¢) = 0 then
14:
ğ¸â†ğ¸âˆª{(ğ‘ ğ‘–,ğ‘¢)}
15:
with probability 1
2: ğ¸â†ğ¸âˆª{(ğ‘¢,ğ‘ ğ‘–)}
16: return ğºâ€² = (ğ‘‰, ğ¸)
Attack Strategy A.3 BFS
Input ğº= (ğ‘‰, ğ¸),ğ‘†, ğµ,ğ‘‘ğ‘¢ğ‘ğ‘™(Â·),ğ‘Ÿ(Â·),ğ‘
Output Generated graph ğºâ€²
1: for each node ğ‘ ğ‘–in set ğ‘†do
2:
ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†âˆ…
3:
ğµğ¹ğ‘†_ğ‘ ğ‘¡ğ‘Ÿğ‘’ğ‘ğ‘šğ‘’ğ‘Ÿâ†BFS starts from node ğ‘‘ğ‘¢ğ‘ğ‘™(ğ‘ ğ‘–)
4:
ğ‘ƒâ†modified_BA(ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†) from Algorithm A.2
5:
for ğ‘–â†1 to ğ‘Â· ğ´ğ¸(ğ‘–) do
6:
if any node is available in ğµğ¹ğ‘†_ğ‘ ğ‘¡ğ‘Ÿğ‘’ğ‘ğ‘šğ‘’ğ‘Ÿ:
7:
ğ‘¢â†next node from ğµğ¹ğ‘†_ğ‘ ğ‘¡ğ‘Ÿğ‘’ğ‘ğ‘šğ‘’ğ‘Ÿ
8:
else:
9:
ğ‘¢â†a random node from (ğµ\ ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ )
following the probability vector ğ‘ƒ
10:
ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ â†ğ‘â„ğ‘œğ‘ ğ‘’ğ‘›_ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ âˆª{ğ‘¢}
11:
if ğ‘Ÿ(ğ‘¢) = 0 then
12:
ğ¸â†ğ¸âˆª{(ğ‘ ğ‘–,ğ‘¢)}
13:
with probability 1
2: ğ¸â†ğ¸âˆª{(ğ‘¢,ğ‘ ğ‘–)}
14: return ğºâ€² = (ğ‘‰, ğ¸)
B
EXAMPLE FOR TRANSFORMER
See Figure B.1 for an example of the transformer used in the proof
of hardness for the maximizing benigns problem.
The transformer converts ğ¼= âŸ¨ğ‘Š,ğ‘„,ğ‘˜âŸ©, which is an instance
of MC, into ğ¼â€² = âŸ¨ğº, ğµ,ğ‘†,ğ‘˜, ğ‘ğ‘Ÿ(Â·)âŸ©, which is an instance of MB.
In this example ğ‘‰ğ‘Š= {ğ‘¤1,ğ‘¤2,ğ‘¤3,ğ‘¤4,ğ‘¤5}, ğ‘‰ğ‘„= {ğ‘1,ğ‘2,ğ‘3,ğ‘4},
and ğ‘1 = {ğ‘¤1,ğ‘¤3}, ğ‘2 = {ğ‘¤5}, ğ‘3 = {ğ‘¤2,ğ‘¤5}, ğ‘4 = {ğ‘¤3,ğ‘¤4}. In
transformation, we have ğµ= ğ‘‰ğ‘„and ğ‘†= âˆ…. We keep the value of ğ‘˜
and set ğ‘ğ‘Ÿ(ğ‘£) = 1 for all nodes based on transformer rules.
Figure B.1: The graph outcome of transformer where ğ‘†= âˆ…
and ğ‘‰ğ‘„= ğµ.
C
SIMPLE GREEDY ALGORITHM
Algorithm C.1 provides the description of the simple greedy al-
gorithm for the maximizing benigns problem. In this algorithm,
we write ğ‘“(ğ´âˆª{ğ‘¢}) for simplicity, but, to be precise, it should be
expressed as ğ‘“(ğ´âˆª{ğ‘¢}, ğµ,ğ‘†, ğ‘ğ‘Ÿ(Â·)), but the other parameters are
clear from the context.
Algorithm C.1 Simple Greedy Algorithm
Input ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†, budget ğ‘˜, ğ‘ğ‘Ÿ(Â·)
Output ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘ğ‘™_ğ‘ ğ‘’ğ‘¡ğ´
1: ğ´â†âˆ…
2: for ğ‘˜iterations do
3:
ğ‘¢â†arg maxğ‘¢âˆˆğ‘‰\ğ´ğ‘“(ğ´âˆª{ğ‘¢})
4:
ğ´â†ğ´âˆª{ğ‘¢}
5: return ğ´
D
PROOF FOR NON-SUBMODULARITY
To prove that the function ğ‘“(Â·) is not submodular, it suffices to
provide an example such that ğ‘£âˆˆğ‘‰,ğ´1 âŠ†ğ´2 and
ğ‘“(ğ´2 âˆª{ğ‘£}) âˆ’ğ‘“(ğ´2) > ğ‘“(ğ´1 âˆª{ğ‘£}) âˆ’ğ‘“(ğ´1)
Consider the graph ğºgiven in Figure D.1, letâ€™s define ğ‘ğ‘Ÿ(ğ‘¢ğ‘–) = 1
for all nodes ğ‘¢ğ‘–, ğ‘†= âˆ…and ğµ= {ğ‘¢1}. We define: ğ´1 = {ğ‘¢1}, ğ´2 =
{ğ‘¢1,ğ‘¢2} and ğ‘£= ğ‘¢3.
Let us compute each of the four entities one by one. We have
ğ‘“(ğ´1) = 1
2 because there is a 1/2 probability that the node ğ‘¢1 is
revealed to be resistant, which results in discovering that the node
ğ‘¢2 is benign. In addition, ğ‘“(ğ´1 âˆª{ğ‘£}) = ğ‘“(ğ´1 âˆª{ğ‘¢3}) = 1
2 because
revealing node ğ‘¢3 cannot result in the discovery of any new benign.
This is true because of Observation 3.1. Thus, ğ‘“(ğ´1âˆª{ğ‘£})âˆ’ğ‘“(ğ´1) =
0.
Furthermore, ğ‘“(ğ´2) = 3
4 because there is a 1/2 probability of
discoveringğ‘¢2 to be benign by revealingğ‘¢1 to be resistant, and then
a 1/2Ã—1/2 = 1/4 probability of discoveringğ‘¢3 if bothğ‘¢1 andğ‘¢2 turn
out to be resistant. We also have ğ‘“(ğ´2 âˆª{ğ‘£}) = 3
4 + ğ‘›âˆ’3
8 , because
we have the same 3
4 as before, and with a probability of 1
8, ğ‘›âˆ’3 new
benigns will be discovered. Thus, we have ğ‘“(ğ´2 âˆª{ğ‘£}) âˆ’ğ‘“(ğ´2) =
ğ‘›âˆ’3
8 . Since ğ‘›âˆ’3
> 0, for any ğ‘›â‰¥4, we can conclude the proof.
Figure D.1: An example to show ğ‘“(Â·) is not submodular.
E
BFS-BASED DISCOVERY ALGORITHM
Below, we provide the Algorithm E.1 for the BFS-based algorithm,
which is used in line 11 of Algorithm 1.
Algorithm E.1 BFS-based Discovery Algorithm
Input ğº= (ğ‘‰, ğ¸), reveal set ğ´, ğµ,ğ‘†,ğ‘Ÿ(Â·)
Output size of discovered set
1: discovered â†âˆ…
2: visited â†âˆ…
3: for ğ‘£âˆˆğ´âˆ©ğµdo
4:
bfs_queue â†empty queue
5:
if ğ‘Ÿ(ğ‘£) = 1 then
6:
bfs_queue.add(ğ‘£)
7:
while bfs_queue is not empty do
8:
ğ‘¤â†bfs_queue.pop()
9:
ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘â†ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘âˆª{ğ‘¤}
10:
discovered â†discovered âˆª(Î“in(ğ‘¤) \ (ğµâˆ©ğ‘†))
11:
for ğ‘¢âˆˆ(Î“in(ğ‘¤) âˆ©ğ´) \ ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘do
12:
if ğ‘Ÿ(ğ‘¢) = 1 then
13:
bfs_queue.add(ğ‘¢)
14: return |ğ‘‘ğ‘–ğ‘ ğ‘ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘’ğ‘‘|
F
BOUND ON ğ‘…IN MONTE CARLO GREEDY
ALGORITHM
Theorem F.1 (Hoeffdingâ€™s ineqality [18]). Consider indepen-
dent random variables ğ‘‹1,ğ‘‹2, . . . ,ğ‘‹ğ‘…such that ğ‘‹ğ‘–âˆˆ[ğ‘,ğ‘], Â¯ğ‘‹is the
mean of ğ‘…random variables and ğœ‡is the expected value of Â¯ğ‘‹. Then,
P( Â¯ğ‘‹âˆ’ğœ‡â‰¥ğœ–) â‰¤exp( âˆ’2ğ‘…ğœ–2
(ğ‘âˆ’ğ‘)2 ), where ğœ–is the error margin.
To gain confidence ğ›¼using the above lemma, one requires ğ‘…â‰¥
(ğ‘âˆ’ğ‘)2 ln(
1âˆ’ğ›¼)
2ğœ–2
. According to the inequality, we have
P( Â¯ğ‘‹âˆ’ğœ‡< ğœ–) â‰¥1 âˆ’exp( âˆ’2ğ‘…ğœ–2
(ğ‘âˆ’ğ‘)2 ).
By setting P( Â¯ğ‘‹âˆ’ğœ‡< ğœ–) â‰¥ğ›¼we will have
1 âˆ’exp( âˆ’2ğ‘…ğœ–2
(ğ‘âˆ’ğ‘)2 ) â‰¥ğ›¼,
Which means
ln(1 âˆ’ğ›¼) â‰¥
âˆ’2ğ‘…ğœ–2
(ğ‘âˆ’ğ‘)2 ,
which yields
ğ‘…â‰¥
(ğ‘âˆ’ğ‘)2 ln(
1âˆ’ğ›¼)
2ğœ–2
.
Suppose that there are ğ‘…Monte Carlo experiments, and the ğ‘–-
th experiment estimates the number of discovered newly benigns
based on each ğ´as ğ‘‹ğ‘–. The above calculated bound on ğ‘…in this
problem will be ğ‘…â‰¥ğ‘˜2Î”2
in ln(
1âˆ’ğ›¼)
2ğœ–2
if we set, ğ‘= 0 andğ‘â‰¤|ğ´|Â·Î”in â‰¤
ğ‘˜Î”in.
G
RUN TIME OF MONTE CARLO GREEDY
ALGORITHM
The complexity of the Monte Carlo Greedy algorithm (described
in Algorithm 1) is determined by the ğ‘˜iterations to each time
identify the best node among at most ğ‘›candidates. For each node,
the computational cost is defined by the EST function. This function
involves assigning ğ‘Ÿ(ğ‘£) for each ğ‘£âˆˆğ´based on ğ‘ğ‘Ÿ(ğ‘£), which incurs
a cost of ğ‘‚(|ğ´|), which is in ğ‘‚(ğ‘›). Subsequently, it computes the
number of discovered benigns using the algorithm described in
Appendix E, which has a complexity of ğ‘‚(ğ‘›+ ğ‘š). This algorithm
runs a BFS with different roots, but as we have a common list of
visited nodes in the algorithm, the complexity is still ğ‘‚(ğ‘›+ ğ‘š).
Therefore, the overall complexity is given by ğ‘‚(ğ‘˜(ğ‘›+ğ‘›Â·ğ‘…(ğ‘›+ğ‘š))),
which simplifies to ğ‘‚(ğ‘˜Â· ğ‘…Â· (ğ‘›2 + ğ‘›ğ‘š)).
H
EXAMPLE FOR TRAVERSING ALGORITHM
Here, we present an example for Algorithm 2, visualized in Fig-
ures H.1 and H.2, to illustrate its execution and the associated data
structure.
We have ğµ= {ğ‘,ğ‘}, ğ‘†= âˆ…and ğ‘= {ğ‘,ğ‘}. Initially, Ë†Î“in(ğ‘) =
{ğ‘‘, ğ‘“}, Ë†Î“in(ğ‘’) = {ğ‘, ğ‘“}, Ë†Î“in(ğ‘) = {ğ‘‘}, ğ›¾in(ğ‘’) = 2, and ğ›¾in(ğ‘) = 1.
In addition, Î“out(ğ‘‘) = {ğ‘,ğ‘}, and Î“out(ğ‘“) = {ğ‘,ğ‘,ğ‘’}. Suppose Al-
gorithm 2 selects ğ‘and ğ‘Ÿ(ğ‘) = 1. Then, in line 9, we will have
ğ‘= {ğ‘,ğ‘} \ {ğ‘} = {ğ‘}. From ğ‘â€™s in-neighbors table, we walk to its
in-neighbors ğ‘‘and ğ‘“. From each of them, by purple links, move to
their out-neighbors. For example, from the node ğ‘“on the left side,
with the help of a purple link, we move to ğ‘“cell in the right table,
and then, for its connected nodes, include ğ‘’and ğ‘(ğ‘is traversed
before, and we do not care about that), we will use orange and
blue links. For example, with the orange link, we go to ğ‘“, which
is connected to ğ‘’in the right table. We will remove that node and
the connection there. Then, we can go to the related counter and
decrease it once. Then we have to move backward and do the same
for cell ğ‘‘in the left table, and from its neighbor ğ‘, with a pink link,
go to node ğ‘‘on the right side and do the same. In the output of this
step, we have: Ë†Î“in(ğ‘’) = {ğ‘}, Ë†Î“in(ğ‘) = {}, ğ›¾in(ğ‘’) = 1, and ğ›¾in(ğ‘) = 0.
Please note that we avoid drawing all links in the figure, as it would
make it really unreadable.
I
REAL-WORLD DATASETS STATISTICS
REPORTS
Table I.1 contains some statistics about the real-world datasets we
used.
Table I.1: Some statistics on real-world networks studied.
Network
Facebook
Twitter
LastFM
Pokec
|Nodes|
4,039
10,000
7,624
10,000
|Undirected Edges|
88,234
27,806
|Directed Edges|
350,600
94,066
Avg ğ‘‘in
43.69
35.06
7.29
9.4
Avg ğ‘‘out
43.69
35.06
7.29
9.4
Is directed?
-
âœ“
-
âœ“
J
DATASETS ADDITIONAL STATISTICS
REPORTS AFTER ATTACKS
For our studied datasets, the statistics after Random, PreAt (Prefer-
ential Attachment), and BFS attacks are summarized in Table J.1.
The number of attack edges and the number of edges that are re-
verse of attacks are shown by |Attacks| and |Rev. Attacks|.
K
RESISTANCE AWARE MONTE CARLO
GREEDY ALGORITHM
Algorithm K.1 describes the Resistance Aware Monte Carlo Greedy
algorithm. This is the variant of the Monte Carlo Greedy algorithm,
which reveals the resistance of each node once it is selected and
leverages that information for the next choices.
Algorithm K.1 Resistance Aware Monte Carlo Greedy Algorithm
Input ğº= (ğ‘‰, ğ¸), ğµ,ğ‘†, budget ğ‘˜, ğ‘ğ‘Ÿ(Â·),ğœ–, ğ›¼
Output ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘ğ‘™_ğ‘ ğ‘’ğ‘¡ğ´
1: Initialize ğ´â†âˆ…
2: Initialize ğ´â€² â†âˆ…
3: for ğ‘–= 1 to ğ‘˜do
4:
ğ‘£â†arg maxğ‘¤âˆˆğ‘‰\ğ´Est(ğ´â€² âˆª{ğ‘¤}, ğ‘ğ‘Ÿ(Â·), ğµ,ğ‘†,ğœ–, ğ›¼)
5:
ğ´â†ğ´âˆª{ğ‘£}
6:
if ğ‘Ÿ(ğ‘£) = 1 then
7:
ğ´â€² â†ğ´â€² âˆª{ğ‘£}
8: return ğ´
9: function Est(ğ´, ğ‘ğ‘Ÿ(Â·), ğµ,ğ‘†,ğœ–, ğ›¼)
10:
Initialize ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡â†0
11:
ğ‘…â†

ğ‘˜2Î”2
in ln(
1âˆ’ğ›¼)
2ğœ–2

12:
for ğ‘…iterations do
13:
Assign resistance ğ‘Ÿ(ğ‘£) for each ğ‘£âˆˆğ´based on ğ‘ğ‘Ÿ(ğ‘£)
14:
ğ‘›ğ‘’ğ‘¤_ğ‘ğ‘’ğ‘›ğ‘–ğ‘”ğ‘›â†number of discovered benigns based
on ğµ, ğ‘†, and assigned resistances.
15:
ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡â†ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡+ ğ‘›ğ‘’ğ‘¤_ğ‘ğ‘’ğ‘›ğ‘–ğ‘”ğ‘›
16:
return ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡/ğ‘…
L
ADDITIONAL EXPERIMENTS FOR
MAXIMIZING BENIGNS
For the experiments of the maximizing benigns problem, the results
on Twitter, LastFM, and Pokec datasets are provided in Figures L.1,
L.2, and L.3.
M
ADDITIONAL EXPERIMENT FOR PAE
For the experiments of discovering potential attack edges problem,
the results on Twitter, LastFM, and Pokec datasets are provided in
Figure M.1.
N
ADDITIONAL EXPERIMENTS FOR
CLASSIFICATION ALGORITHMS
For other node classification experiments on Twitter, LastFM and
Pokec dataset, Table N.1 is provided.
Figure H.1: Data structure schema used to update neighborhoods in Algorithm 2. First, starting
from ğ‘with purple lines, we can reach ğ‘‘and ğ‘“on the right side table, and then based on three
lines shown by blue, orange, and pink lines, we can apply the updates.
Figure H.2: Example graph
for describing the data struc-
ture used in Algorithm 2.
Nodes ğ‘and ğ‘form the be-
nign set.
Table J.1: Statistics for Facebook, Twitter, LastFM, and Pokec datasets after Random, PreAt (Preferential Attachment), and BFS
attacks. ğ‘ â†’ğ‘ and ğ‘â†’ğ‘indicate sybil-to-sybil and benign-to-benign edges. The next four rows represent the average number
of incoming/outgoing edges for sybils and benigns. ğ‘Ÿ(Â·) and ğ‘ğ‘Ÿ(Â·) represent resistance and probability of resistance.
Statistic
Facebook+
Twitter+
LastFM+
Pokec+
Random
PreAt
BFS
Random
PreAt
BFS
Random
PreAt
BFS
Random
PreAt
BFS
|ğ¸ğ‘‘ğ‘”ğ‘’ğ‘ |
222080
361687
351979
67546
128875
125539
|ğ´ğ‘¡ğ‘¡ğ‘ğ‘ğ‘˜ğ‘ |
25396
25073
18619
3919
16870
14683
|ğ‘…ğ‘’ğ‘£. ğ´ğ‘¡ğ‘¡ğ‘ğ‘ğ‘˜ğ‘ |
12678
12585
9331
1983
8494
7345
|ğ‘ â†’ğ‘ |
7538
16484
16484
6032
9446
9446
|ğ‘â†’ğ‘|
176468
307545
307545
55612
94065
94065
Avg ğ‘‘in Sybils
34.71
50.16
34.44
29.069
39.571
25.815
9.953
10.518
9.528
17.94
22.531
16.791
Avg ğ‘‘out Sybils
50.97
81.72
49.77
41.557
62.452
35.103
11.936
13.059
11.236
26.316
35.536
24.129
Avg ğ‘‘in Benigns
46.91
49.98
46.79
33.262
35.351
32.616
7.696
7.808
7.626
11.094
12.016
10.875
Avg ğ‘‘out Benigns
45.29
46.83
45.26
32.013
33.063
31.688
7.498
7.554
7.455
10.256
10.715
10.141
Avg ğ‘Ÿ(Â·)
0.7658
0.7658
0.7658
0.7519
0.7519
0.7519
0.7542
0.7542
0.7542
0.7464
0.7464
0.7464
Avg ğ‘ğ‘Ÿ(Â·)
0.6225
0.6309
0.6431
0.6216
0.6248
0.6222
0.6278
0.6310
0.6287
0.6214
0.6194
0.6268
Figure L.1: The number of discovered benigns by each algorithm when the budget ranges from 1 to ğ‘˜in the maximizing benigns
problem on the Twitter dataset and for different attack strategies.
Figure L.2: The number of discovered benigns by each algorithm when the budget ranges from 1 to ğ‘˜in the maximizing benigns
problem on the LastFM dataset and for different attack strategies.
Figure L.3: The number of discovered benigns by each algorithm when the budget ranges from 1 to ğ‘˜in the maximizing benigns
problem on the Pokec dataset and for different attack strategies.
(a) Twitter dataset
(b) LastFM dataset
(c) Pokec dataset
Figure M.1: The number of discovered PAEs for different budgets (first row) and the percentage of attack edges relative to the
number of discovered PAEs (second row) on Twitter (a), LastFM (b), and Pokec (c) datasets. Each column represents a different
attack strategy.
Table N.1: Performance of SybilSCAR, SybilWalk, and SybilMetric with and without preprocessing on the Twitter, LastFM,
and Pokec datasets. Init represents the setup without preprocessing. MB incorporates discovered benigns by the Traversing
algorithm. MB+PAE incorporates both discovered benigns and PAEs.
Dataset
Attack
Strategy
Step
SybilSCAR
AUC
SybilWalk
AUC
SybilMetric
AUC
Twitter
Random
Init
0.901
0.918
0.82
MB
0.935
0.972
0.95
MB+PAE
0.936
0.973
0.92
BA
Init
0.891
0.889
0.83
MB
0.934
0.961
0.96
MB+PAE
0.936
0.966
0.96
BFS
Init
0.909
0.931
0.75
MB
0.942
0.977
0.94
MB+PAE
0.946
0.981
0.95
LastFM
Random
Init
0.951
0.952
0.90
MB
0.958
0.966
0.95
MB+PAE
0.960
0.966
0.94
BA
Init
0.932
0.944
0.91
MB
0.937
0.957
0.94
MB+PAE
0.947
0.959
0.90
BFS
Init
0.948
0.971
0.88
MB
0.953
0.980
0.95
MB+PAE
0.961
0.981
0.92
Pokec
Random
Init
0.895
0.924
0.90
MB
0.916
0.946
0.94
MB+PAE
0.913
0.948
0.89
BA
Init
0.852
0.916
0.90
MB
0.893
0.936
0.94
MB+PAE
0.901
0.940
0.93
BFS
Init
0.903
0.953
0.86
MB
0.936
0.968
0.92
MB+PAE
0.937
0.968
0.90